/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 bot.glb
*/

import React, { useRef, useEffect, useMemo } from 'react'
import { CameraHelper, Vector3 } from 'three'
import { Capsule } from 'three/examples/jsm/math/Capsule.js'
import {  useFrame } from '@react-three/fiber'
import { useGLTF, useHelper, useAnimations, PerspectiveCamera } from '@react-three/drei'
import useKeyboard from './useKeyboard'


const GRAVITY = 30
const STEPS_PER_FRAME = 5
const COLLIDER_RADIUS = 0.4
const COLLIDER_HEIGHT = 1

export function Bot({ octree }) {
  const playerOnFloor = useRef(false)
  const avatar = useRef()
  const pov = useRef()
  const capsuleRef = useRef()

  const spawnAt = new Vector3(0, 2, 0)

  const playerVelocity = useMemo(() => new Vector3(), [])
  const playerDirection = useMemo(() => new Vector3(), [])
  
  const capsuleStart = new Vector3().copy(spawnAt)
  const capsuleEnd = new Vector3(spawnAt.x, spawnAt.y + COLLIDER_HEIGHT, spawnAt.z)
  // eslint-disable-next-line
  const capsule = useMemo(() => new Capsule(capsuleStart, capsuleEnd, COLLIDER_RADIUS), [])

  // Load model
  const { nodes, animations } = useGLTF('./models/Bot/bot.glb')
  const head = nodes.mixamorigHead

  // Attach POV camera only once
  if (pov.current) {
    head.add(pov.current)
  }
  // Show camera frustum in development
  useHelper(pov, CameraHelper)

  // Extract animations
  const { actions } = useAnimations(animations, avatar)

  const keyboard = useKeyboard()

  function getForwardVector(playerDirection) {
    capsuleRef.current.getWorldDirection(playerDirection)
    playerDirection.y = 0
    playerDirection.normalize()
    return playerDirection
  }

  function getSideVector(playerDirection) {
    capsuleRef.current.getWorldDirection(playerDirection)
    playerDirection.y = 0
    playerDirection.normalize()
    playerDirection.cross(capsuleRef.current.up)
    return playerDirection
  }
  
  function controls(
    delta,
    playerVelocity,
    playerOnFloor,
    playerDirection
  ) {
    const speedDelta = delta * (playerOnFloor ? 18 : 8)
    keyboard['KeyA'] &&
      playerVelocity.add(
        getSideVector(playerDirection).multiplyScalar(-speedDelta)
      )
    keyboard['KeyD'] &&
      playerVelocity.add(
        getSideVector(playerDirection).multiplyScalar(speedDelta)
      )
    keyboard['KeyW'] &&
      playerVelocity.add(
        getForwardVector(playerDirection).multiplyScalar(speedDelta)
      )
    keyboard['KeyS'] &&
      playerVelocity.add(
        getForwardVector(playerDirection).multiplyScalar(-speedDelta)
      )
    keyboard['KeyK'] &&
      capsuleRef.current.rotateY(delta)
    keyboard['KeyL'] &&
      capsuleRef.current.rotateY(-delta)

    if (playerOnFloor) {
      if (keyboard['Space']) {
        playerVelocity.y = 10
      }
    }
  }

  function updatePlayer(
    delta,
    octree,
    capsule,
    playerVelocity,
    playerOnFloor
  ) {
    let damping = Math.exp(-4 * delta) - 1
    if (!playerOnFloor) {
      playerVelocity.y -= GRAVITY * delta
      damping *= 0.1 // small air resistance
    }
    playerVelocity.addScaledVector(playerVelocity, damping)
    const deltaPosition = playerVelocity.clone().multiplyScalar(delta)
    capsule.translate(deltaPosition)
    playerOnFloor = playerCollisions(capsule, octree, playerVelocity)

    // Update collider which will automatically move the character's components
    capsuleRef.current.position.set(capsule.start.x, capsule.start.y + 2.5, capsule.start.z)
    return playerOnFloor
  }

  function playerCollisions(capsule, octree, playerVelocity) {
    const result = octree.capsuleIntersect(capsule)
    let playerOnFloor = false
    if (result) {
      playerOnFloor = result.normal.y > 0
      if (!playerOnFloor) {
        playerVelocity.addScaledVector(
          result.normal,
          -result.normal.dot(playerVelocity)
        )
      }
      capsule.translate(result.normal.multiplyScalar(result.depth))
    }
    return playerOnFloor
  }
  
  function teleportPlayerIfOob(capsule, playerVelocity) {
    if (capsuleRef.current.position.y <= -100) {
      playerVelocity.set(0, 0, 0)
      capsule.start.set(spawnAt.x, spawnAt.y, spawnAt.z)
      capsule.end.set(spawnAt.x, spawnAt.y + COLLIDER_HEIGHT, spawnAt.z)
      capsuleRef.current.position.set(capsule.start.x, capsule.start.y + 2.5, capsule.start.z)
    }
  }

  useFrame((state, delta) => {
    controls(
      delta,
      playerVelocity,
      playerOnFloor.current,
      playerDirection
    )

    const deltaSteps = Math.min(0.05, delta) / STEPS_PER_FRAME

    for (let i = 0; i < STEPS_PER_FRAME; i++) {
      playerOnFloor.current = updatePlayer(
        deltaSteps,
        octree,
        capsule,
        playerVelocity,
        playerOnFloor.current
      )
    }

    teleportPlayerIfOob(capsule, playerVelocity)
  })

  useEffect(() => {
    actions.Walking_FullBody.fadeIn(0.5)
    actions.Walking_FullBody.play()
  })

  return (
    <mesh ref={capsuleRef}>
      <capsuleGeometry args={[COLLIDER_RADIUS, COLLIDER_HEIGHT, 2, 8]} />
      <meshBasicMaterial color="red" wireframe />
      
      <group ref={avatar} name="Bot" position={[0, -0.9, 0]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <PerspectiveCamera ref={pov} near={15} far={50000} rotation={[0, Math.PI, 0]} makeDefault={false} />
        <primitive object={nodes.mixamorigHips} />
        <skinnedMesh name="Alpha_Joints" geometry={nodes.Alpha_Joints.geometry} skeleton={nodes.Alpha_Joints.skeleton}>
          <meshToonMaterial color="black" />
        </skinnedMesh>
        <skinnedMesh name="Alpha_Surface" geometry={nodes.Alpha_Surface.geometry} skeleton={nodes.Alpha_Surface.skeleton}>
          <meshToonMaterial color="slateblue" />
        </skinnedMesh>
      </group>
    </mesh>

  )
}

useGLTF.preload('./models/Bot/bot.glb')
